/**
 * Enhanced Analytics Service for Clinical Decision Support\n * Tracks usage patterns, clinical outcomes, and system performance\n */\n\nimport cacheService from './cacheService.js';\nimport supabaseService from '../config/supabase.js';\n\nclass EnhancedAnalyticsService {\n  constructor() {\n    // Event types for tracking\n    this.eventTypes = {\n      // User interactions\n      LOGIN: 'user_login',\n      LOGOUT: 'user_logout',\n      SEARCH: 'drug_search',\n      INTERACTION_CHECK: 'interaction_check',\n      RECOMMENDATION_VIEW: 'recommendation_view',\n      \n      // Clinical actions\n      DRUG_PRESCRIBED: 'drug_prescribed',\n      INTERACTION_OVERRIDE: 'interaction_override',\n      ALTERNATIVE_SELECTED: 'alternative_selected',\n      MONITORING_SCHEDULED: 'monitoring_scheduled',\n      \n      // System events\n      ERROR_OCCURRED: 'error_occurred',\n      PERFORMANCE_METRIC: 'performance_metric',\n      CACHE_HIT: 'cache_hit',\n      CACHE_MISS: 'cache_miss',\n      \n      // Clinical outcomes\n      ADVERSE_EVENT: 'adverse_event',\n      TREATMENT_RESPONSE: 'treatment_response',\n      DOSAGE_ADJUSTMENT: 'dosage_adjustment'\n    };\n\n    // Metrics aggregation\n    this.metrics = {\n      dailyStats: new Map(),\n      userActivity: new Map(),\n      drugPopularity: new Map(),\n      interactionPatterns: new Map(),\n      errorRates: new Map()\n    };\n\n    // Performance tracking\n    this.performanceMetrics = {\n      responseTime: [],\n      memoryUsage: [],\n      cacheHitRate: [],\n      errorCount: 0\n    };\n\n    // Privacy and compliance settings\n    this.privacySettings = {\n      anonymizeUserData: process.env.ANONYMIZE_ANALYTICS === 'true',\n      retentionDays: parseInt(process.env.ANALYTICS_RETENTION_DAYS) || 90,\n      enableClinicalTracking: process.env.ENABLE_CLINICAL_TRACKING === 'true',\n      requireConsent: process.env.REQUIRE_ANALYTICS_CONSENT === 'true'\n    };\n\n    this.initializeAnalytics();\n  }\n\n  /**\n   * Initialize analytics service\n   */\n  async initializeAnalytics() {\n    console.log('ðŸ” Initializing enhanced analytics service...');\n    \n    // Start periodic metric collection\n    this.startPeriodicCollection();\n    \n    // Load historical data\n    await this.loadHistoricalMetrics();\n    \n    console.log('âœ… Enhanced analytics service initialized');\n  }\n\n  /**\n   * Track user event with context\n   */\n  async trackEvent(eventType, eventData, userContext = {}) {\n    try {\n      const timestamp = new Date();\n      const sessionId = this.generateSessionId();\n      \n      // Create event object\n      const event = {\n        id: this.generateEventId(),\n        type: eventType,\n        timestamp: timestamp.toISOString(),\n        sessionId,\n        data: eventData,\n        user: this.anonymizeUserData(userContext),\n        metadata: this.getSystemMetadata()\n      };\n\n      // Store event\n      await this.storeEvent(event);\n      \n      // Update real-time metrics\n      this.updateMetrics(event);\n      \n      // Trigger real-time processing if needed\n      if (this.isHighPriorityEvent(eventType)) {\n        await this.processHighPriorityEvent(event);\n      }\n      \n      return event.id;\n      \n    } catch (error) {\n      console.error('Failed to track event:', error);\n      this.trackError('event_tracking_failed', error, { eventType });\n    }\n  }\n\n  /**\n   * Track drug search patterns\n   */\n  async trackDrugSearch(query, results, userContext) {\n    const searchData = {\n      query: query.toLowerCase().trim(),\n      resultCount: results.length,\n      responseTime: results.responseTime || 0,\n      source: results.source || 'unknown',\n      timestamp: new Date().toISOString()\n    };\n\n    await this.trackEvent(this.eventTypes.SEARCH, searchData, userContext);\n    \n    // Update drug popularity metrics\n    this.updateDrugPopularity(query, results);\n  }\n\n  /**\n   * Track interaction checks\n   */\n  async trackInteractionCheck(drugs, interactions, riskLevel, userContext) {\n    const interactionData = {\n      drugCount: drugs.length,\n      drugs: drugs.map(d => this.anonymizeDrugData(d)),\n      interactionCount: interactions.length,\n      majorInteractions: interactions.filter(i => i.severity === 'major').length,\n      riskLevel,\n      timestamp: new Date().toISOString()\n    };\n\n    await this.trackEvent(this.eventTypes.INTERACTION_CHECK, interactionData, userContext);\n    \n    // Update interaction pattern analytics\n    this.updateInteractionPatterns(drugs, interactions);\n  }\n\n  /**\n   * Track clinical decisions\n   */\n  async trackClinicalDecision(decisionType, outcome, reasoning, userContext) {\n    const decisionData = {\n      type: decisionType,\n      outcome,\n      reasoning,\n      confidence: outcome.confidence || 0,\n      evidenceLevel: outcome.evidenceLevel || 'unknown',\n      timestamp: new Date().toISOString()\n    };\n\n    await this.trackEvent('clinical_decision', decisionData, userContext);\n  }\n\n  /**\n   * Track treatment outcomes (for clinical effectiveness analysis)\n   */\n  async trackTreatmentOutcome(patientId, treatmentPlan, outcome, followUpData) {\n    if (!this.privacySettings.enableClinicalTracking) {\n      return;\n    }\n\n    const outcomeData = {\n      patientId: this.anonymizePatientId(patientId),\n      treatment: this.anonymizeTreatmentData(treatmentPlan),\n      outcome: {\n        effectiveness: outcome.effectiveness,\n        adverseEvents: outcome.adverseEvents || [],\n        durationDays: outcome.durationDays || 0,\n        dosageAdjustments: outcome.dosageAdjustments || 0\n      },\n      followUp: followUpData,\n      timestamp: new Date().toISOString()\n    };\n\n    await this.trackEvent(this.eventTypes.TREATMENT_RESPONSE, outcomeData);\n  }\n\n  /**\n   * Track system performance metrics\n   */\n  async trackPerformance(metricName, value, context = {}) {\n    const performanceData = {\n      metric: metricName,\n      value,\n      context,\n      timestamp: new Date().toISOString()\n    };\n\n    await this.trackEvent(this.eventTypes.PERFORMANCE_METRIC, performanceData);\n    \n    // Store in performance metrics for real-time monitoring\n    if (metricName === 'response_time') {\n      this.performanceMetrics.responseTime.push({ value, timestamp: Date.now() });\n      \n      // Keep only last 1000 entries\n      if (this.performanceMetrics.responseTime.length > 1000) {\n        this.performanceMetrics.responseTime = this.performanceMetrics.responseTime.slice(-1000);\n      }\n    }\n  }\n\n  /**\n   * Track errors with context\n   */\n  async trackError(errorType, error, context = {}) {\n    const errorData = {\n      type: errorType,\n      message: error.message || error,\n      stack: error.stack,\n      context,\n      timestamp: new Date().toISOString()\n    };\n\n    await this.trackEvent(this.eventTypes.ERROR_OCCURRED, errorData);\n    \n    this.performanceMetrics.errorCount++;\n  }\n\n  /**\n   * Generate analytics dashboard data\n   */\n  async getDashboardMetrics(timeRange = '7d', userRole = null) {\n    try {\n      const cacheKey = `dashboard_metrics_${timeRange}_${userRole || 'all'}`;\n      \n      // Try cache first\n      let metrics = await cacheService.getCachedAnalytics(cacheKey);\n      \n      if (!metrics) {\n        metrics = await this.calculateDashboardMetrics(timeRange, userRole);\n        await cacheService.cacheAnalytics(cacheKey, metrics);\n      }\n      \n      return metrics;\n      \n    } catch (error) {\n      console.error('Failed to generate dashboard metrics:', error);\n      return this.getDefaultDashboardMetrics();\n    }\n  }\n\n  /**\n   * Calculate comprehensive dashboard metrics\n   */\n  async calculateDashboardMetrics(timeRange, userRole) {\n    const endDate = new Date();\n    const startDate = new Date();\n    \n    // Calculate date range\n    switch (timeRange) {\n      case '24h':\n        startDate.setDate(endDate.getDate() - 1);\n        break;\n      case '7d':\n        startDate.setDate(endDate.getDate() - 7);\n        break;\n      case '30d':\n        startDate.setDate(endDate.getDate() - 30);\n        break;\n      case '90d':\n        startDate.setDate(endDate.getDate() - 90);\n        break;\n    }\n\n    // Query analytics data\n    const events = await this.getEventsInRange(startDate, endDate, userRole);\n    \n    // Calculate metrics\n    const metrics = {\n      overview: this.calculateOverviewMetrics(events),\n      usage: this.calculateUsageMetrics(events),\n      clinical: this.calculateClinicalMetrics(events),\n      performance: this.calculatePerformanceMetrics(events),\n      safety: this.calculateSafetyMetrics(events),\n      trends: this.calculateTrendMetrics(events, timeRange)\n    };\n\n    return metrics;\n  }\n\n  /**\n   * Calculate overview metrics\n   */\n  calculateOverviewMetrics(events) {\n    const totalUsers = new Set(events.map(e => e.user?.id).filter(id => id)).size;\n    const totalSessions = new Set(events.map(e => e.sessionId)).size;\n    const totalInteractionChecks = events.filter(e => e.type === this.eventTypes.INTERACTION_CHECK).length;\n    const totalSearches = events.filter(e => e.type === this.eventTypes.SEARCH).length;\n\n    return {\n      totalUsers,\n      totalSessions,\n      totalInteractionChecks,\n      totalSearches,\n      avgSessionDuration: this.calculateAverageSessionDuration(events)\n    };\n  }\n\n  /**\n   * Calculate usage metrics\n   */\n  calculateUsageMetrics(events) {\n    const hourlyUsage = this.calculateHourlyUsage(events);\n    const topSearches = this.calculateTopSearches(events);\n    const userRoleDistribution = this.calculateUserRoleDistribution(events);\n    const featureUsage = this.calculateFeatureUsage(events);\n\n    return {\n      hourlyUsage,\n      topSearches,\n      userRoleDistribution,\n      featureUsage\n    };\n  }\n\n  /**\n   * Calculate clinical metrics\n   */\n  calculateClinicalMetrics(events) {\n    const interactionEvents = events.filter(e => e.type === this.eventTypes.INTERACTION_CHECK);\n    const majorInteractions = interactionEvents.reduce((sum, e) => \n      sum + (e.data?.majorInteractions || 0), 0\n    );\n    \n    const riskDistribution = this.calculateRiskDistribution(interactionEvents);\n    const drugCombinations = this.calculateTopDrugCombinations(interactionEvents);\n    const overrideRate = this.calculateOverrideRate(events);\n\n    return {\n      totalMajorInteractions: majorInteractions,\n      riskDistribution,\n      topDrugCombinations: drugCombinations,\n      overrideRate,\n      averageRiskScore: this.calculateAverageRiskScore(interactionEvents)\n    };\n  }\n\n  /**\n   * Calculate performance metrics\n   */\n  calculatePerformanceMetrics(events) {\n    const performanceEvents = events.filter(e => e.type === this.eventTypes.PERFORMANCE_METRIC);\n    const errorEvents = events.filter(e => e.type === this.eventTypes.ERROR_OCCURRED);\n    \n    const avgResponseTime = this.calculateAverageResponseTime(performanceEvents);\n    const errorRate = errorEvents.length / events.length;\n    const cacheHitRate = this.calculateCacheHitRate(events);\n\n    return {\n      averageResponseTime: avgResponseTime,\n      errorRate: Math.round(errorRate * 10000) / 100, // Percentage with 2 decimals\n      cacheHitRate: Math.round(cacheHitRate * 100),\n      totalErrors: errorEvents.length,\n      uptimePercentage: this.calculateUptimePercentage(events)\n    };\n  }\n\n  /**\n   * Generate clinical insights report\n   */\n  async generateClinicalInsights(timeRange = '30d') {\n    const events = await this.getEventsInRange(\n      new Date(Date.now() - this.parseTimeRange(timeRange)),\n      new Date()\n    );\n\n    const insights = {\n      drugSafety: this.analyzeDrugSafetyPatterns(events),\n      interactionTrends: this.analyzeInteractionTrends(events),\n      userBehavior: this.analyzeUserBehaviorPatterns(events),\n      systemEffectiveness: this.analyzeSystemEffectiveness(events)\n    };\n\n    return insights;\n  }\n\n  /**\n   * Export analytics data for research\n   */\n  async exportAnalyticsData(filters = {}, format = 'json') {\n    if (!this.hasExportPermission(filters.requestedBy)) {\n      throw new Error('Insufficient permissions for data export');\n    }\n\n    const data = await this.getFilteredAnalyticsData(filters);\n    const anonymizedData = this.deepAnonymizeData(data);\n\n    switch (format) {\n      case 'csv':\n        return this.convertToCSV(anonymizedData);\n      case 'excel':\n        return this.convertToExcel(anonymizedData);\n      default:\n        return anonymizedData;\n    }\n  }\n\n  /**\n   * Helper methods\n   */\n  anonymizeUserData(userContext) {\n    if (!this.privacySettings.anonymizeUserData) {\n      return userContext;\n    }\n\n    return {\n      id: this.hashUserId(userContext.id),\n      role: userContext.role,\n      institution: userContext.institution ? 'redacted' : undefined\n    };\n  }\n\n  anonymizePatientId(patientId) {\n    return this.hashUserId(`patient_${patientId}`);\n  }\n\n  anonymizeDrugData(drug) {\n    return {\n      category: drug.category || 'unknown',\n      class: drug.class || 'unknown'\n    };\n  }\n\n  hashUserId(id) {\n    // Simple hash for demonstration - use proper crypto hash in production\n    let hash = 0;\n    for (let i = 0; i < id.length; i++) {\n      const char = id.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32bit integer\n    }\n    return `user_${Math.abs(hash)}`;\n  }\n\n  generateSessionId() {\n    return `sess_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  generateEventId() {\n    return `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  getSystemMetadata() {\n    return {\n      version: process.env.APP_VERSION || '1.0.0',\n      environment: process.env.NODE_ENV || 'development',\n      server: process.env.SERVER_ID || 'unknown'\n    };\n  }\n\n  isHighPriorityEvent(eventType) {\n    return [\n      this.eventTypes.ADVERSE_EVENT,\n      this.eventTypes.ERROR_OCCURRED,\n      this.eventTypes.INTERACTION_OVERRIDE\n    ].includes(eventType);\n  }\n\n  async processHighPriorityEvent(event) {\n    // Send real-time alerts for critical events\n    if (event.type === this.eventTypes.ADVERSE_EVENT) {\n      await this.sendAdverseEventAlert(event);\n    }\n  }\n\n  async storeEvent(event) {\n    // Store in database\n    if (supabaseService.enabled) {\n      try {\n        await supabaseService.client\n          .from('analytics_events')\n          .insert(event);\n      } catch (error) {\n        console.error('Failed to store event in database:', error);\n        // Fall back to cache storage\n        await cacheService.set(`event_${event.id}`, event, 3600); // 1 hour TTL\n      }\n    }\n  }\n\n  updateMetrics(event) {\n    // Update real-time metrics in memory\n    const today = new Date().toISOString().split('T')[0];\n    \n    if (!this.metrics.dailyStats.has(today)) {\n      this.metrics.dailyStats.set(today, {\n        events: 0,\n        users: new Set(),\n        searches: 0,\n        interactions: 0\n      });\n    }\n\n    const dayStats = this.metrics.dailyStats.get(today);\n    dayStats.events++;\n    \n    if (event.user?.id) {\n      dayStats.users.add(event.user.id);\n    }\n    \n    if (event.type === this.eventTypes.SEARCH) {\n      dayStats.searches++;\n    }\n    \n    if (event.type === this.eventTypes.INTERACTION_CHECK) {\n      dayStats.interactions++;\n    }\n  }\n\n  startPeriodicCollection() {\n    // Collect system metrics every 5 minutes\n    setInterval(async () => {\n      await this.collectSystemMetrics();\n    }, 5 * 60 * 1000);\n    \n    // Clean up old data daily\n    setInterval(() => {\n      this.cleanupOldData();\n    }, 24 * 60 * 60 * 1000);\n  }\n\n  async collectSystemMetrics() {\n    const memUsage = process.memoryUsage();\n    const cacheStats = cacheService.getStats();\n    \n    await this.trackPerformance('memory_usage', memUsage.heapUsed);\n    await this.trackPerformance('cache_hit_rate', cacheStats.hitRate);\n  }\n\n  cleanupOldData() {\n    const cutoff = Date.now() - (this.privacySettings.retentionDays * 24 * 60 * 60 * 1000);\n    \n    // Clean up in-memory metrics\n    for (const [date, stats] of this.metrics.dailyStats.entries()) {\n      if (new Date(date).getTime() < cutoff) {\n        this.metrics.dailyStats.delete(date);\n      }\n    }\n  }\n\n  getDefaultDashboardMetrics() {\n    return {\n      overview: {\n        totalUsers: 0,\n        totalSessions: 0,\n        totalInteractionChecks: 0,\n        totalSearches: 0,\n        avgSessionDuration: 0\n      },\n      usage: {\n        hourlyUsage: [],\n        topSearches: [],\n        userRoleDistribution: {},\n        featureUsage: {}\n      },\n      clinical: {\n        totalMajorInteractions: 0,\n        riskDistribution: {},\n        topDrugCombinations: [],\n        overrideRate: 0,\n        averageRiskScore: 0\n      },\n      performance: {\n        averageResponseTime: 0,\n        errorRate: 0,\n        cacheHitRate: 0,\n        totalErrors: 0,\n        uptimePercentage: 100\n      }\n    };\n  }\n}\n\nexport default new EnhancedAnalyticsService();