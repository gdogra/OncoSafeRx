name: Deploy API to Render

on:
  workflow_dispatch: {}
  push:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'package.json'
      - 'package-lock.json'
      - 'Dockerfile'

jobs:
  trigger-render-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Predeploy smoke (optional)
        id: pre_smoke
        env:
          PREDEPLOY_SMOKE_URL: ${{ secrets.PREDEPLOY_SMOKE_URL }}
        run: |
          if [ -z "$PREDEPLOY_SMOKE_URL" ]; then
            echo "Predeploy smoke skipped (PREDEPLOY_SMOKE_URL not set)"
            exit 0
          fi
          set -euo pipefail
          sudo apt-get update -y && sudo apt-get install -y jq
          BASE=${PREDEPLOY_SMOKE_URL%/}
          echo "Running predeploy smoke for: $BASE"
          curl -fsS "$BASE/health" | jq . >/dev/null
          RESP=$(curl -fsS "$BASE/api/health")
          echo "$RESP" | jq . >/dev/null
          STATUS=$(echo "$RESP" | jq -r .status)
          [ "$STATUS" = "healthy" ] || { echo "API health not healthy" >&2; exit 1; }
          HTML=$(curl -fsS "$BASE/")
          ASSET=$(echo "$HTML" | grep -Eo '/assets/[^" ]+\.js' | head -n 1)
          [ -n "$ASSET" ] || { echo "No JS asset found in index" >&2; exit 1; }
          curl -fsS "$BASE$ASSET" >/dev/null
          CSS=$(echo "$HTML" | grep -Eo '/assets/[^" ]+\.css' | head -n 1 || true)
          if [ -n "$CSS" ]; then curl -fsS "$BASE$CSS" >/dev/null; fi
          echo "Predeploy smoke passed for $BASE"
      - name: Trigger Render deploy hook
        env:
          RENDER_DEPLOY_HOOK: ${{ secrets.RENDER_DEPLOY_HOOK }}
        run: |
          if [ -z "$RENDER_DEPLOY_HOOK" ]; then
            echo "RENDER_DEPLOY_HOOK secret not set. Add it in GitHub repo settings." >&2
            exit 1
          fi
          echo "Triggering Render deploy..."
          curl -fsS -X POST "$RENDER_DEPLOY_HOOK" -o /dev/null
          echo "Deploy hook sent. Check Render dashboard for status."

      - name: Install jq (for JSON parsing)
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Poll Render deploy status (optional)
        id: poll
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          RENDER_SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
          RENDER_DEPLOY_HOOK: ${{ secrets.RENDER_DEPLOY_HOOK }}
        run: |
          if [ -z "$RENDER_API_KEY" ]; then
            echo "RENDER_API_KEY not set — skipping status poll."; exit 0; fi

          SERVICE_ID="$RENDER_SERVICE_ID"
          if [ -z "$SERVICE_ID" ] && [ -n "$RENDER_DEPLOY_HOOK" ]; then
            # Try to extract service id from hook URL (/deploy/<serviceId>?key=...)
            SERVICE_ID=$(echo "$RENDER_DEPLOY_HOOK" | sed -n 's#.*/deploy/\([^?]*\).*#\1#p')
          fi
          if [ -z "$SERVICE_ID" ]; then
            echo "Render service id not available — set RENDER_SERVICE_ID secret to enable polling."; exit 0; fi

          AUTH="Authorization: Bearer $RENDER_API_KEY"
          BASE="https://api.render.com/v1"
          echo "Polling deploy status for service: $SERVICE_ID"

          # Wait up to ~10 minutes
          for i in $(seq 1 60); do
            RESP=$(curl -fsS -H "$AUTH" "$BASE/services/$SERVICE_ID/deploys?limit=1") || true
            STATUS=$(echo "$RESP" | jq -r '.[0].status // empty')
            ID=$(echo "$RESP" | jq -r '.[0].id // empty')
            if [ -n "$STATUS" ]; then
              echo "Attempt $i: status=$STATUS id=$ID"
              case "$STATUS" in
                succeeded)
                  echo "Render deploy succeeded."
                  echo "status=$STATUS" >> $GITHUB_OUTPUT
                  echo "deploy_id=$ID" >> $GITHUB_OUTPUT
                  exit 0;;
                failed|canceled)
                  echo "Render deploy failed with status: $STATUS" >&2
                  echo "status=$STATUS" >> $GITHUB_OUTPUT
                  echo "deploy_id=$ID" >> $GITHUB_OUTPUT
                  exit 1;;
                *)
                  sleep 10;;
              esac
            else
              echo "Attempt $i: could not fetch status (empty response)."; sleep 10
            fi
          done
          echo "Timed out waiting for Render deploy to finish." >&2
          echo "status=timeout" >> $GITHUB_OUTPUT
          exit 1

      - name: Post-deploy health check (required if URL set)
        if: success()
        id: health
        env:
          RENDER_SERVICE_URL: ${{ secrets.RENDER_SERVICE_URL }}
        run: |
          if [ -z "$RENDER_SERVICE_URL" ]; then
            echo "Skipping health check (RENDER_SERVICE_URL not set)"
            echo "ok=skipped" >> $GITHUB_OUTPUT
            exit 0
          fi
          set -euo pipefail
          BASE=${RENDER_SERVICE_URL%/}
          echo "Probing health at: $BASE"
          ok="false"
          for i in $(seq 1 60); do
            if curl -fsS "$BASE/health" >/dev/null; then ok="true"; break; fi
            sleep 5
          done
          echo "ok=$ok" >> $GITHUB_OUTPUT
          echo "url=$BASE" >> $GITHUB_OUTPUT
          echo "checked_at=$(date -Is)" >> $GITHUB_OUTPUT
          if [ "$ok" = "true" ]; then
            echo "Health JSON:" && curl -fsS "$BASE/health" | jq . || true
            echo "API health JSON:" && curl -fsS "$BASE/api/health" | jq . || true
          else
            echo "Health check failed for $BASE" >&2
            exit 1
          fi

      - name: Assert frontend runtime config (post-deploy)
        if: success()
        id: cfg
        env:
          RENDER_SERVICE_URL: ${{ secrets.RENDER_SERVICE_URL }}
        run: |
          if [ -z "$RENDER_SERVICE_URL" ]; then
            echo "Skipping frontend config assertion (RENDER_SERVICE_URL not set)"
            exit 0
          fi
          set -euo pipefail
          BASE=${RENDER_SERVICE_URL%/}
          CFG=$(curl -fsS "$BASE/api/frontend/config")
          echo "$CFG" | jq .
          URL=$(echo "$CFG" | jq -r '.supabaseUrl // empty')
          KEY=$(echo "$CFG" | jq -r '.supabaseAnonKey // empty')
          if [ -z "$URL" ] || [ -z "$KEY" ]; then
            echo "Missing frontend runtime config: supabaseUrl or supabaseAnonKey is empty" >&2
            exit 1
          fi

      - name: Notify Slack/Teams (success)
        if: success()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          TEAMS_WEBHOOK: ${{ secrets.TEAMS_WEBHOOK }}
        run: |
          MSG="✅ Render deploy succeeded for $GITHUB_REPOSITORY@${GITHUB_SHA::7} status=${{ steps.poll.outputs.status }} deploy_id=${{ steps.poll.outputs.deploy_id }} health=${{ steps.health.outputs.ok }} url=${{ steps.health.outputs.url }}"
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            payload=$(jq -n --arg text "$MSG" '{text: $text}')
            curl -fsS -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK_URL" || true
          fi
          if [ -n "$TEAMS_WEBHOOK" ]; then
            payload=$(jq -n --arg text "$MSG" '{text: $text}')
            curl -fsS -X POST -H 'Content-Type: application/json' -d "$payload" "$TEAMS_WEBHOOK" || true
          fi

      - name: Notify Slack/Teams (failure)
        if: failure()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          TEAMS_WEBHOOK: ${{ secrets.TEAMS_WEBHOOK }}
        run: |
          MSG="❌ Render deploy FAILED for $GITHUB_REPOSITORY@${GITHUB_SHA::7} status=${{ steps.poll.outputs.status }} deploy_id=${{ steps.poll.outputs.deploy_id }} health=${{ steps.health.outputs.ok }} url=${{ steps.health.outputs.url }}"
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            payload=$(jq -n --arg text "$MSG" '{text: $text}')
            curl -fsS -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK_URL" || true
          fi
          if [ -n "$TEAMS_WEBHOOK" ]; then
            payload=$(jq -n --arg text "$MSG" '{text: $text}')
            curl -fsS -X POST -H 'Content-Type: application/json' -d "$payload" "$TEAMS_WEBHOOK" || true
          fi

      - name: Attempt rollback to previous deploy (optional)
        if: failure()
        id: rollback
        continue-on-error: true
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          RENDER_SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
          RENDER_ROLLBACK_ON_FAILURE: ${{ secrets.RENDER_ROLLBACK_ON_FAILURE }}
        run: |
          set -euo pipefail
          if [ -z "${RENDER_ROLLBACK_ON_FAILURE:-}" ] || [ "${RENDER_ROLLBACK_ON_FAILURE}" != "true" ]; then
            echo "Rollback disabled (set RENDER_ROLLBACK_ON_FAILURE=true to enable)"
            echo "rolled_back=disabled" >> $GITHUB_OUTPUT
            exit 0
          fi
          if [ -z "${RENDER_API_KEY:-}" ] || [ -z "${RENDER_SERVICE_ID:-}" ]; then
            echo "Missing RENDER_API_KEY or RENDER_SERVICE_ID — cannot rollback"
            echo "rolled_back=skipped" >> $GITHUB_OUTPUT
            exit 0
          fi
          BASE="https://api.render.com/v1"
          AUTH="Authorization: Bearer $RENDER_API_KEY"
          echo "Finding previous successful deploy for service: $RENDER_SERVICE_ID"
          DEPLOYS=$(curl -fsS -H "$AUTH" "$BASE/services/$RENDER_SERVICE_ID/deploys?limit=10")
          # Prefer the most recent succeeded deploy that is not the last attempted deploy
          LAST_ATTEMPT="${{ steps.poll.outputs.deploy_id }}"
          TARGET=$(echo "$DEPLOYS" | jq -r --arg last "$LAST_ATTEMPT" 'map(select((.status=="succeeded") and (.id!=$last)))[0].id // ""')
          if [ -z "$TARGET" ]; then
            echo "No previous successful deploy found to rollback to."
            echo "rolled_back=not_found" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Attempting rollback to deploy: $TARGET"
          # Render API rollback endpoint (may vary by API version). If this 404s, manual rollback is required.
          RSP=$(curl -sS -o /dev/stderr -w "%{http_code}" -X POST -H "$AUTH" "$BASE/services/$RENDER_SERVICE_ID/deploys/$TARGET/rollback") || true
          if [ "$RSP" != "200" ] && [ "$RSP" != "201" ] && [ "$RSP" != "202" ]; then
            echo "Rollback API call returned HTTP $RSP; rollback may not be supported by API."
            echo "rolled_back=api_failed" >> $GITHUB_OUTPUT
            echo "target_deploy=$TARGET" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "Rollback triggered to $TARGET" 
          echo "rolled_back=triggered" >> $GITHUB_OUTPUT
          echo "target_deploy=$TARGET" >> $GITHUB_OUTPUT

      - name: Notify Slack/Teams (rollback)
        if: failure()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          TEAMS_WEBHOOK: ${{ secrets.TEAMS_WEBHOOK }}
        run: |
          STATUS="${{ steps.rollback.outputs.rolled_back }}"
          TARGET="${{ steps.rollback.outputs.target_deploy }}"
          MSG="↩️ Render rollback status: $STATUS target_deploy=$TARGET service=${{ secrets.RENDER_SERVICE_ID }} repo=$GITHUB_REPOSITORY sha=${GITHUB_SHA::7}"
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            payload=$(jq -n --arg text "$MSG" '{text: $text}')
            curl -fsS -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK_URL" || true
          fi
          if [ -n "$TEAMS_WEBHOOK" ]; then
            payload=$(jq -n --arg text "$MSG" '{text: $text}')
            curl -fsS -X POST -H 'Content-Type: application/json' -d "$payload" "$TEAMS_WEBHOOK" || true
          fi

      - name: Poll rollback deploy status (optional)
        if: failure()
        id: poll_rollback
        env:
          RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
          RENDER_SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
        run: |
          set -euo pipefail
          TARGET="${{ steps.rollback.outputs.target_deploy }}"
          if [ -z "${RENDER_API_KEY:-}" ] || [ -z "${RENDER_SERVICE_ID:-}" ] || [ -z "$TARGET" ]; then
            echo "Rollback polling skipped (missing API key/service id/target)."
            echo "status=skipped" >> $GITHUB_OUTPUT
            exit 0
          fi
          BASE="https://api.render.com/v1"
          AUTH="Authorization: Bearer $RENDER_API_KEY"
          echo "Polling rollback deploy $TARGET"
          STATUS="pending"
          for i in $(seq 1 60); do
            RESP=$(curl -fsS -H "$AUTH" "$BASE/deploys/$TARGET") || true
            STATUS=$(echo "$RESP" | jq -r '.status // empty')
            echo "Attempt $i: status=$STATUS"
            case "$STATUS" in
              succeeded)
                echo "status=$STATUS" >> $GITHUB_OUTPUT
                echo "deploy_id=$TARGET" >> $GITHUB_OUTPUT
                exit 0;;
              failed|canceled)
                echo "status=$STATUS" >> $GITHUB_OUTPUT
                echo "deploy_id=$TARGET" >> $GITHUB_OUTPUT
                exit 0;;
              *)
                sleep 10;;
            esac
          done
          echo "status=timeout" >> $GITHUB_OUTPUT
          echo "deploy_id=$TARGET" >> $GITHUB_OUTPUT
          exit 0

      - name: Post-rollback health check (optional)
        if: failure()
        id: health_rollback
        continue-on-error: true
        env:
          RENDER_SERVICE_URL: ${{ secrets.RENDER_SERVICE_URL }}
        run: |
          if [ -z "$RENDER_SERVICE_URL" ]; then
            echo "ok=skipped" >> $GITHUB_OUTPUT
            exit 0
          fi
          set -euo pipefail
          BASE=${RENDER_SERVICE_URL%/}
          echo "Probing health after rollback at: $BASE"
          ok="false"
          for i in $(seq 1 60); do
            if curl -fsS "$BASE/health" >/dev/null; then ok="true"; break; fi
            sleep 5
          done
          echo "ok=$ok" >> $GITHUB_OUTPUT
          echo "url=$BASE" >> $GITHUB_OUTPUT
          if [ "$ok" = "true" ]; then
            echo "Health JSON:" && curl -fsS "$BASE/health" | jq . || true
          fi

      - name: Notify Slack/Teams (rollback health)
        if: failure()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          TEAMS_WEBHOOK: ${{ secrets.TEAMS_WEBHOOK }}
        run: |
          STATUS="${{ steps.poll_rollback.outputs.status }}"
          HEALTH="${{ steps.health_rollback.outputs.ok }}"
          MSG="🩺 Post-rollback health: $HEALTH rollback_status=$STATUS service=${{ secrets.RENDER_SERVICE_ID }} repo=$GITHUB_REPOSITORY sha=${GITHUB_SHA::7}"
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            payload=$(jq -n --arg text "$MSG" '{text: $text}')
            curl -fsS -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK_URL" || true
          fi
          if [ -n "$TEAMS_WEBHOOK" ]; then
            payload=$(jq -n --arg text "$MSG" '{text: $text}')
            curl -fsS -X POST -H 'Content-Type: application/json' -d "$payload" "$TEAMS_WEBHOOK" || true
          fi

      - name: Email notify (success)
        if: success()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.EMAIL_HOST }}
          server_port: ${{ secrets.EMAIL_PORT }}
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: ✅ Render deploy succeeded: ${{ github.repository }}@${{ github.sha }}
          to: ${{ secrets.EMAIL_TO }}
          from: ${{ secrets.EMAIL_FROM }}
          content_type: text/plain
          body: |
            Render deployment succeeded.
            Repo: ${{ github.repository }}
            Commit: ${{ github.sha }}
            Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      - name: Email notify (failure)
        if: failure()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.EMAIL_HOST }}
          server_port: ${{ secrets.EMAIL_PORT }}
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: ❌ Render deploy FAILED: ${{ github.repository }}@${{ github.sha }}
          to: ${{ secrets.EMAIL_TO }}
          from: ${{ secrets.EMAIL_FROM }}
          content_type: text/plain
          body: |
            Render deployment failed.
            Repo: ${{ github.repository }}
            Commit: ${{ github.sha }}
            Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
